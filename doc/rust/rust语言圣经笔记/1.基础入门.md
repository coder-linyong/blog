# 变量绑定与解构

## 变量命名

rust变量命名和其他语言没有不同，但需要遵循[命名规范](https://course.rs/practice/naming.html)

## 变量绑定

在JavaScript中，可通过`var a = "hello world"`给变量a赋值；类似的，在rust中可通过`let a = "hello world"`，将字符串对象绑定给变量a，这一过程叫
**变量绑定**（**所有权**绑定）

## 变量可变性

Rust变量默认情况下是**不可变的**，这个语言特性让Rust代码更安全，可通过`mut`关键字让变量可变：

```rust
fn main() {
  let mut x = 5;
  println!("The value of x is: {}", x);
  x = 6;
  println!("The value of x is: {}", x);
}
```

得到输出结果如下：

```rust
$ cargo run
Compiling variables v0.1.0 (file:///projects/variables)
Finished dev [unoptimized + debuginfo] target(s) in 0.30s
Running `target/debug/variables`
The value of x is: 5
The value of x is: 6

```

## 使用下划线开头忽略未使用的变量

rust会对未使用的变量发出警告，因为这可能是个bug；但在项目建立之初，有未使用变量是很正常的，这时候可通过下划线开头的变量告诉rust编译器忽略警告：

```rust
fn main() {
  let _x = 5;//不发出警告
  let y = 10;//发出警告
}
```

控制台输出如下：

```rust
warning: unused variable: `y`
- -> src/main.rs:3: 9
|
3 | let y = 10;
| ^ help: 如果 y 故意不被使用，请添加一个下划线前缀: `_y`
|
= note: ` # [warn(unused_variables)]` on by default
```

## 变量解构

`let`表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：

```rust
fn main() {
  let (a, mut b): (bool, bool) = (true, false);
  // a = true,不可变; b = false，可变
  println!("a = {:?}, b = {:?}", a, b);

  b = true;
  assert_eq!(a, b);
}
```

### 解构赋值

可以在赋值语句的左式中使用元组、切片和结构体模式：

```rust
struct Struct {
  e: i32
}

fn main() {
  let (a, b, c, d, e);

  (a, b) = (1, 2);
  // _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _
  [c, .., d, _] = [1, 2, 3, 4, 5];
  Struct { e,..
} = Struct { e: 5 };

  assert_eq ! ([1, 2, 1, 4, 5], [a, b, c, d, e]);
  }
```

**使用 += 的赋值语句还不支持解构式赋值**

## 变量和常量之间的差异

**常量**是绑定到一个常量名且不允许更改的值，常量可以定义在任意作用域内。常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性。

常量和变量之前的区别：

- 常量不能用`mut`关键字；**常量不仅默认不可变，而且始终不可变**，因为常量在编译后已经确定其值
- 常量用`const`关键字声明，且必须标注类型

```rust

#![allow(unused)]

fn main() {
  const MAX_POINTS: u32 = 100_000;
}
```

### 变量遮蔽shadowing

Rust允许声明同名变量，后面的变量会被前面的变量遮蔽。

```rust
fn main() {
  let x = 5;
  // 在main函数的作用域内对之前的x进行遮蔽
  let x = x + 1;

  {
    // 在当前的花括号作用域内，对之前的x进行遮蔽
    let x = x * 2;
    println!("The value of x in the inner scope is: {}", x);
  }

  println!("The value of x is: {}", x);
}
```

输出内容如下：

```rust
$ cargo run
Compiling variables v0.1.0 (file:///projects/variables)
...
The value of x in the inner scope is: 12
The value of x is: 6
```

变量遮蔽涉及内存对象再分配，而`mut`则是修改同一内存地址的值，性能会更好。

变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。如：

```rust

#![allow(unused)]

fn main() {
// 字符串类型
  let spaces = "   ";
// usize数值类型
  let spaces = spaces.len();
}
```

# 基本类型

Rust每个值都有确切的类型，可分为两种：基本数据类型和复合类型。

基本数据类型最小原子类型，无法结构成其他类型：

- 数值类型: 有符号整数 (`i8`,` i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`,` u32`, `u64`, `usize`)
  、浮点数 (`f32`, `f64`)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 `&str`
- 布尔类型： `true`和`false`
- 字符类型: 表示单个 `Unicode` 字符，存储为 4 个字节
- 单元类型: 即 () ，其唯一的值也是 ()

### 类型推导与标注

与 Python、JavaScript 等动态语言不同，Rust 是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为
**Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型**
，同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注。

## 数值类型

### 整数类型

**整数**是没有小数部分的数字。`i`是英文单词integer的首字母，与之相反的是`u`，代表无符号unsigned类型。

| 长度    | 有符号类型 | 无符号类型 |
|-------|-------|-------|
| 8位    | i8    | u8    |
| 16位   | i16   | u16   |
| 32位   | i32   | u32   |
| 64位   | i64   | u64   |
| 128位  | i128  | u128  |
| 视框架而定 | isize | usize |

- 有符号类型规定数字是-(2n-1) ~ 2n-1 - 1，其中n是该定义形式的位长度，如：`i8`可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~127。
- 有符号类型可存储数字范围是0 ~ 2n - 1，所以 `u8` 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。
- `isize`和`usize`取决于计算机CPU类型：CPU是32位的，则是32位的；CPU是64位的，则是64位的

整形字面量可以使用下面形式书写：

| 数字字面量       | 示例          |
|-------------|-------------|
| 十进制         | 98_222      |
| 十六进制        | 0xff        |
| 八进制         | 0o77        |
| 二进制         | 0b1111_0000 |
| 字节 (仅限于 u8) | b'A'        |

**Rust整形默认使用i32类型，建议首选，因为这个类型往往是性能最好的类型；**`**isize**`**和**`**usize**`**的场景主要用作集合的索引
**

**整形溢出**
当一个值修改到其范围之外的值时，会发生**整形溢出**，Rust对于**整形溢出**有些有趣的规则：

- 使用debug模式编译时，Rust会检查**整形溢出**，如果存在则会在编译时崩溃（panic，Rust使用这个术语表达程序因错误而退出）
- 使用`--release`参数进行release模式构建时，Rust不检测溢出。Rust会按照补码循环溢出（two’s complement
  wrapping）的规则处理；如在`U8`的情况下，265变成0,257变成1，以此类推。程序不会崩溃，但这种行为是一种Bug，处理这些行为的方法如下
    - 使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
    - 如果使用 checked_* 方法时发生溢出，则返回 None 值
    - 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
    - 使用 saturating_* 方法使值达到最小值或最大值

```rust
fn main() {
  let mut num: u8 = 255;
  num = num.wrapping_add(10);
  println!("{}", num);//9
}
```

### 浮点类型

**浮点类型数字**是带有小数的数字，在Rust中浮点类型数字有两种基本类型：

- f32（单精度浮点型）
- f64（双精度浮点型，默认浮点类型，与f32速度几乎相同，但精度更高）

**浮点数陷阱**
浮点数由于底层特殊性，导致如果在使用浮点数时不够谨慎，可能会造成危险，原因如下：

- **浮点数往往是某个数字的近似表达**：浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1
  在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行
- **浮点数在某些特性上是反直觉的**：如f32 ， f64 上的比较运算实现的是 std::cmp::PartialEq 特征(类似其他语言的接口)，但是并没有实现
  std::cmp::Eq 特征，但是后者在其它数值类型上都有定义

为了避免上面说的两个陷阱，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

### NaN

数学中未定义的结果，如对负数取平方根（`-42.1.sqrt()`），会产生一个特殊的结果：Rust的浮点数类型使用NaN（not a number）来处理这些情况。

**所有跟NaN交互的操作，都会返回NaN，而且NaN不能用来比较**，下面的代码将会崩溃：

```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```

可使用`is_nan`等方法判断是否是`NaN`：

```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  if x.is_nan() {
    println!("未定义的数学行为")
  }
}
```

### 数字运算

Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。

```rust
fn main() {
  // 加法
  let sum = 5 + 10;

  // 减法
  let difference = 95.5 - 4.3;

  // 乘法
  let product = 4 * 30;

  // 除法
  let quotient = 56.7 / 32.2;

  // 求余
  let remainder = 43 % 5;
}
```

```rust
fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;

  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];

  // 打印数组中第一个值，并控制小数位为2位
  println!("{:.2}", forty_twos[0]);
}
```

### 位运算

Rust的运算基本上和其他语言一样

| 运算符       | 说明                           |
|-----------|------------------------------|
| & 位与      | 相同位置均为1时则为1，否则为0             |
| &#124; 位或 | 相同位置只要有1时则为1，否则为0            |
| ^ 异或      | 相同位置不相同则为1，相同则为0             |
| ! 位非      | 把位中的0和1相互取反，即0置为1，1置为0       |
| << 左移     | 所有位向左移动指定位数，右位补0             |
| >> 右移     | 所有位向右移动指定位数，带符号移动（正数补0，负数补1） |

```rust
fn main() {
  // 二进制为00000010
  let a: i32 = 2;
  // 二进制为00000011
  let b: i32 = 3;

  println!("(a & b) value is {}", a & b);

  println!("(a | b) value is {}", a | b);

  println!("(a ^ b) value is {}", a ^ b);

  println!("(!b) value is {} ", !b);

  println!("(a << b) value is {}", a << b);

  println!("(a >> b) value is {}", a >> b);

  let mut a = a;
  // 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)
  a <<= b;
  println!("(a << b) value is {}", a);
}
```

### 序列

Rust提供一个非常简洁的方式生成连续的数值，如：1..5表示生成1到4的连续数字，不包含5；1..=5表示从1到5连续的数字，包含5：

```rust
fn main() {
  for i in 1..=5 {
    println!("{}", i);
  }
}
```

同事，能够用于字符类型（字符可以连续，a-z），同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型：

```rust
fn main() {
  for i in 'a'..='z' {
    println!("{}", i)
  }
  for i in 'A'..='Z' {
    println!("{}", i)
  }
}
```

### 有理数和复数

Rust中有理数和复数并未包含在标准库中：

- 有理数和复数
- 任意大小的整数和任意精度的浮点数
- 固定精度的十进制小数，常用于货币相关的场景

社区中高质量Rust数值库[num](https://crates.io/crates/num)可解决这种问题

```rust
use num::complex::Complex;

fn main() {
  let a = Complex { re: 2.1, im: -1.2 };
  let b = Complex::new(11.1, 22.2);
  let result = a + b;

  println!("{} + {}i", result.re, result.im)
}
```

## 字符、布尔、单元类型

### 字符类型（char)

Rust中，所有的`Unicode`（U+0000 ~ U+D7FF）值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。

由于 Unicode 都是 4 个字节编码，因此字符类型也是占用 4 个字节：

```rust
fn main() {
  let x = 'a';
  println!("{}", std::mem::size_of_val(&x));//4
}
```

### 布尔（bool）

布尔类型只有两个值`true`和`false`，占用内存大小为1字节。

```rust
fn main() {
  let t = true;

  let f: bool = false; // 使用类型标注,显式指定f的类型

  if f {
    println!("这是段毫无意义的代码");
  }
}
```

### 单元类型

单元类型是`()`，同时`()`也是单元类型唯一的值。如：`main`函数和`println!()`函数返回的都是单元类型。

**单元类型可以作为一个值用来占位，但完全不占用任何内存**

## 语句和表达式

- 语句：以`;`结尾，执行操作但不返回任何值
- 表达式：不以`;`结尾，执行操作并返回值，**只要能够返回值的都是表达式**;表达式如果不返回任何职，则会默认返回`()`

> 对于 Rust 语言而言，**这种基于语句（statement）和表达式（expression）的方式是非常重要的，你需要能明确的区分这两个概念**,
> 但是对于很多其它语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征，**表达式总要返回值**。

```rust
fn main() {
  fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
  }
}
```

## 函数

一个函数如下结构：

```rust
fn main() {
  fn add(i: i32, j: i32) -> i32 {
    i + j
  }
}
```

结构说明：

- 声明函数的关键字`fn`
- 函数名`add()`
- 参数`i`和`j`
- 参数类型和返回值类型都是`i32`

### 函数要点

- 函数名和变量名使用[蛇形命名法(snake case)](https://course.rs/practice/naming.html)，例如 fn add_two() -> {}
- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
- 每个函数参数都需要标注类型

### 函数参数

Rust是强类型语言，因此需要为每个函数参数都标识出具体类型，如：

```rust
fn main() {
  another_function(5, 6.1);
}

fn another_function(x: i32, y: f32) {
  println!("The value of x is: {}", x);
  println!("The value of y is: {}", y);
}
```

### 函数返回

Rust中函数是表达式，函数返回值可以直接赋值给调用者，在函数中可通过return提前返回值，或者通过最后一行的表达式返回值：

```rust
fn main() {
  println!("{}", fun(120))
}

fn fun(n: i32) -> i32 {
  // 大于100，提前返回
  if n > 100 {
    return n - 10;
  }
  n + 10
}
```

#### 特殊返回类型

##### 无返回值()

单元类型`()`可以用来表达一个函数没有返回值

- 函数没有返回值，那么返回一个`()`
- 通过`;`结尾的表达式返回一个`()`

```rust
// 隐式返回()
fn report<T: Debug>(item: T) {
  println!("{:?}", item);
}

// 显式返回()
fn clear(text: &mut String) -> () {
  *text = String::from("");
}
```

##### 永不返回的发散函数 !

当用`!`作函数返回类型的时候，表示该函数永不返回（diverge function），特别的，这种语法往往用做会导致程序崩溃的函数：

```rust
// 程序崩溃时
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}

// 无限循环时
fn forever() -> ! {
  loop {
    //...
  };
}
```

# 所有权与借用

## 所有权

内存管理的三种流派：

- **垃圾回收机制(GC)**：在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- **手动管理内存的分配和释放**： 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- **通过所有权来管理内存**：编译器在编译时会根据一系列规则进行检查

### 栈(Stack)与堆(Heap)

- 栈：栈按照顺序存储值并以相反顺序取出值，这也被称作**后进先出**。增加数据叫做**进栈**，移出数据则叫做**出栈**
  。栈中所有数据都必须占用已知固定大小的内存空间。
- 对于大小未知或者可能变化的数据，我们需要将它存储在堆上。当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的
  **指针**,
  该过程被称为**在堆上分配内存**，有时简称为 “分配”(allocating)。该指针会被推入**栈**
  中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。

性能区别：

- 写入方面：入栈要比在堆上非配内存要快，因为无需分配空间。
- 读取方面：访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。

> 栈数据往往可以直接存储在 CPU 高速缓存中，而堆数据只能存储在内存中。

### 所有权原则

> 1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
> 2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
> 3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

### 变量绑定背后的数据交互

#### 转移所有权

对于基本数据类型而言，因为固定大小的值，其值存储在栈中，赋值操作通过自动拷贝，无需在堆上分配内存。因为数据足够简单，拷贝速度远比在堆上创建内存快。如：

```rust
fn main() {
  let x = 5;
  let y = x;
}
```

对于复杂数类型而言，一个变量赋值给另一个变量其实是转移所有权。

以下面代码为例：

```rust
fn main() {
  let s1 = String::from("hello");
  let s2 = s1;
}
```

[String类型](https://course.rs/basic/compound-type/string-slice.html)**由存储在栈中的堆指针、字符串长度、字符串容量共同组成
**：

- **堆指针**是最重要的，他指向真是存储字符串内容的堆内存
- 字符串容量是堆内存分配空间的大小
- 字符串长度是已使用的大小

基于所有权原则，上面代码赋值效果其实是这样的：
> **当 s1 赋予 s2 后，Rust 认为 s1 不再有效，因此也无需在 s1 离开作用域后 drop 任何东西，这就是把所有权从 s1 转移给了 s2，s1
在被赋予 s2 后就马上失效了。**

如果在所有权转移后再使用旧的所有则，将会报错：

```rust
fn main() {
  let s1 = String::from("hello");
  let s2 = s1;

  println!("{}, world!", s1);
}
```

报错如下：

```
error[E0382]: use of moved value: `s1`
 --> src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
```

所以Rust中如`let a = b`的变量定义被叫做**变量绑定**

#### 克隆（深拷贝）

**Rust 永远也不会自动创建数据的 “深拷贝”**。因此，任何**自动**的复制都不是深拷贝，可以被认为对运行时性能影响较小。
如`String`类型需要深度复制可使用`clone`的方法（使用此方法会降低程序性能）：

```rust
fn main() {
  let s1 = String::from("hello");
  let s2 = s1.clone();
  println!("{}，{}", s1, s2);
}
```

#### 拷贝（浅拷贝）

浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。如：

```rust
fn main() {
  let x = 5;
  let y = x;

  println!("x = {}, y = {}", x, y);
}
```

> Rust 有一个叫做 `Copy` 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 Copy 特征，一个旧的变量在被赋值给其他变量后仍然可用。

任何基本类型的组合都可以`Copy`，不需要分配内存或某种形式资源的类型是可以`Copy`的，如：

- 所有整数类型，比如 u32
- 布尔类型，bool，它的值是 true 和 false
- 所有浮点数类型，比如 f64
- 字符类型，char
- 元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 不是
- 不可变引用 &T ，例如转移所有权中的最后一个例子，**但可变引用 `&mut T` 是不可以 `Copy`的**

### 函数传值与返回

将值传递给函数，一样会发生`移动`或者`复制`，就跟`let`语句一样，下面的代码展示了所有权、作用域的规则：

```rust
fn main() {
  let s = String::from("hello");  // s 进入作用域

  takes_ownership(s);             // s 的值移动到函数里 ...
  // ... 所以到这里不再有效

  let x = 5;                      // x 进入作用域

  makes_copy(x);                  // x 应该移动函数里，
  // 但 i32 是 Copy 的，所以在后面可继续使用 x
} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
// 所以不会有特殊操作

fn takes_ownership(some_string: String) { // some_string 进入作用域
  println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
  println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```

同样的，函数返回值也有所有权，例如:

```rust
fn main() {
  let s1 = gives_ownership();         // gives_ownership 将返回值
  // 移给 s1

  let s2 = String::from("hello");     // s2 进入作用域

  let s3 = takes_and_gives_back(s2);  // s2 被移动到
  // takes_and_gives_back 中,
  // 它也将返回值移给 s3
} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
// 所以什么也不会发生。s1 移出作用域并被丢弃

fn gives_ownership() -> String {             // gives_ownership 将返回值移动给
  // 调用它的函数

  let some_string = String::from("hello"); // some_string 进入作用域.

  some_string                              // 返回 some_string 并移出给调用的函数
}

// takes_and_gives_back 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域

  a_string  // 返回 a_string 并移出给调用的函数
}
```

## 引用与借用

**获取变量的引用，称之为借用(borrowing)**

### 引用与解引用

常规引用是一个指针类型，指向了对象存储的内存地址。通过引用操作`&`引用变量，在通过借引用操作符`*`解出引用指向的值（**解引用**
）如：

```rust
fn main() {
  let x = 5;
  let y = &x;//引用x
  assert_eq!(5, x);
  // 对y进行解引用，解析出y所指向的值，整数不能和引用作比较
  assert_eq!(5, *y);
}
```

### 不可变引用和可变引用

可通过将变量的引用传入函数，这样可避免值被丢弃（因为不曾拥有），同时代码会更加简洁。

同变量一样，没有通过`mut`声明默认不可变（不可变引用）

```rust
fn main() {
  let x = String::from("hello");
  println!("{},{}", x, get_length(&x))
}

fn get_length(s: &String) -> usize {
  s.len()
}
```

可通过mut声明为可变引用：

```rust
fn main() {
  let mut x = String::from("hello");
  push(&mut x);
  println!("{}", x)
}

fn push(s: &mut String) {
  s.push_str(" word");
}
```

**可变引用与不可变引用不能同时存在**，因为借用不可变引用时如果出现可变引用时将会出现混乱。如下面的代码将会报错：

```rust
fn main() {
  let mut s = String::from("hello");

  let r1 = &s; // 没问题
  let r2 = &s; // 没问题
  let r3 = &mut s; // 大问题

  println!("{}, {}, and {}", r1, r2, r3);
}
```

报错如下

```
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
        // 无法借用可变 `s` 因为它已经被借用了不可变
 --> src/main.rs:6:14
  |
4 |     let r1 = &s; // 没问题
  |              -- immutable borrow occurs here 不可变借用发生在这里
5 |     let r2 = &s; // 没问题
6 |     let r3 = &mut s; // 大问题
  |              ^^^^^^ mutable borrow occurs here 可变借用发生在这里
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here 不可变借用在这里使用
```

> 注意，引用的作用域从创建开始，一直持续到它最后一次使用的地方，而变量的作用域从创建持续到某一个花括号 }

在新版本编译器中，下面代码将不会报错，因为**引用作用域的结束位置从花括号变成最后一次使用的位置**：

```rust
fn main() {
  let mut s = String::from("hello");

  let r1 = &s;
  let r2 = &s;
  println!("{} and {}", r1, r2);
  // 新编译器中，r1,r2作用域在这里结束

  let r3 = &mut s;
  println!("{}", r3);
} // 老编译器中，r1、r2、r3作用域在这里结束
// 新编译器中，r3作用域在这里结束
```

**Non-Lexical Lifetimes(NLL)**：编译器优化行为，专门用于找到某个引用在作用域(**}**)结束前就不再被使用的代码位置。

### 悬垂引用

悬垂引用（悬垂指针）：某个指针指向某个值后，这个值被释放，但指针仍然存在，指针指向的内存可能不存在任何值或已被其他变量重新使用。
Rust中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。

如：

```rust
fn main() {
  let reference_to_nothing = dangle();
}

fn dangle() -> &String { // dangle 返回一个字符串的引用

  let s = String::from("hello"); // s 是一个新字符串

  &s // 返回字符串 s 的引用
} // 这里 s 离开作用域并被丢弃。其内存被释放。
// 危险！
```

则会报错如下：

```
error[E0106]: missing lifetime specifier
 --> src/main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -> &'static String {
  |                ~~~~~~~~
```

最好的解决方法是直接返回`String`：

```rust
fn main() {
  fn no_dangle() -> String {
    let s = String::from("hello");

    s
  }
}
```

# 复合类型

## 字符串与切片

### 切片

切片允许你引用集合中部分连续的元素序列，而不是引用整个集合。
切片对于字符串而言就是对字符串中某一部分的引用：

```rust
fn main() {
  let s = String::from("hello world");

  let hello = &s[0..5];
  let world = &s[6..11];
}
```

切片语法为**[开始索引..终止索引]**。这是个`右半开区间`，开始索引是切片第一个元素索引位置，终止索引是切片最后一个元素索引后一个位置。
如果从0开始可以省略开始索引，下面两种切片方式是等效的：

```rust
fn main() {
  let s = String::from("hello");

  let slice = &s[0..2];
  let slice = &s[..2];
}
```

如果切片到最后一个，则可以省略终止索引下面两种切片方式是等效的：

```rust
fn main() {
  let s = String::from("hello");

  let len = s.len();

  let slice = &s[4..len];
  let slice = &s[4..];
}
```

综上，截取完整的切片可省略开始索引和终止索引,下面两种切片方式是等效的：

```rust
fn main() {
  let s = String::from("hello");

  let len = s.len();

  let slice = &s[0..len];
  let slice = &s[..];
}
```

需要格外注意对字符的切片预发，如中文在UTF-8中占三个字节，如果不是按照字符边界取就会导致代码崩溃：

```rust
fn main() {
  let s = "中国人";
  let a = &s[0..2];
  println!("{}", a);
}
```

对于上面问题可参考[操作 UTF-8 字符串](https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C-utf-8-%E5%AD%97%E7%AC%A6%E4%B8%B2)

### 字符串字面量是切片

字符串字面量的类型是切片（`&str`），他指向程序可执行文件中的某个点，是个不可变得引用。下面两种写法是等效的：

```rust
fn main() {
  let s = "Hello, world!";
  let s: &str = "Hello, world!";
}
```

### 字符串

字符串是由字符组成的连续集合（UTF-8编码），Rust的字符串中的字符所占字节是变化的（1-4），这样有助于降低内存空间占用。

Rust语言级别只有一种字符串类型——`str`，但在标准库中有多种不同用途的字符串，如使用最广泛地`String`类型。
`str`类型是硬编码进可执行文件，无法被修改；`String`则是一个可增长、可改变且具有所有权的UTF-8编码字符串。*
*当Rust用户提到字符串时，往往指的就是`String`类型和`&str`字符串切片类型，这两个类型都是UTF-8编码。**

除了String类型字符串，Rust标准库中提供了其他类型字符串，如：`OsString`、`OsStr`、`CsString`、`CsStr`，其中以`String`、`str`
结尾分别对应的是具有所有权和被借用的变量。

### String与&Str的转换