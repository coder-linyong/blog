# 模式匹配

## `match`和`if let`

### `match`匹配

Rust中的`match`和其他语言中的`switch`相似，如：

```rust
enum Direction {
  East,
  West,
  North,
  South,
}

fn main() {
  let dire = Direction::South;
  // match 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同
  match dire {
    Direction::East => println!("East"),
    // X | Y，类似逻辑运算符 或，代表该分支可以匹配 X 也可以匹配 Y，只要满足一个即可
    Direction::North | Direction::South => {
      println!("South or North");
    }
    // match 的匹配必须要穷举出所有可能，因此这里用 _ 来代表未列出的所有可能性
    _ => println!("West"),
  };
}
```

`match`的通用形势如下：

```
fn main() {
  match target {
    模式1 => 表达式1,
    模式2 => {
        语句1;
        语句2;
        表达式2
    },
    _ => 表达式3
  }
}
```

#### 使用`match`表达式赋值

`match`本身也是个表达式，可用于赋值：

```rust
enum IpAddr {
  Ipv4,
  Ipv6,
}

fn main() {
  let ip1 = IpAddr::Ipv6;
  let ip_str = match ip1 {
    IpAddr::Ipv4 => "127.0.0.1",
    _ => "::1",
  };

  println!("{}", ip_str);
}
```

#### 模式绑定

模式匹配有个重要的功能就是从模式中取值，如：

```rust
enum Action {
  Say(String),
  MoveTo(i32, i32),
  ChangeColor(u8, u8, u8),
}

fn main() {
  let actions = [
    Action::Say("hello".to_string()),
    Action::MoveTo(20, 30),
    Action::ChangeColor(255, 255, 255),
  ];
  for action in actions {
    match action {
      Action::Say(s) => { println!("{}", s); }
      Action::MoveTo(x, y) => { println!("move to ({},{})", x, y); }
      Action::ChangeColor(r, g, b) => { println!("color is rgb({},{},{})", r, g, b); }
    }
  }
}
```

#### 穷尽匹配

`match`的匹配必须穷尽所有情况，如：

```rust
enum Direction {
  East,
  West,
  North,
  South,
}

fn main() {
  let dire = Direction::South;
  match dire {
    Direction::East => println!("East"),
    Direction::North | Direction::South => {
      println!("South or North");
    }
  };
}
```

将会报错如下信息：

```
error[E0004]: non-exhaustive patterns: `West` not covered // 非穷尽匹配，`West` 没有被覆盖
  --> src/main.rs:10:11
   |
1  | / enum Direction {
2  | |     East,
3  | |     West,
   | |     ---- not covered
4  | |     North,
5  | |     South,
6  | | }
   | |_- `Direction` defined here
...
10 |       match dire {
   |             ^^^^ pattern `West` not covered // 模式 `West` 没有被覆盖
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Direction`
```

#### `_` 通配符

`match`匹配中可通过`_`通配符匹配所有没有列出的项：

```rust

#![allow(unused)]

fn main() {
  let some_u8_value = 0u8;
  match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
  }
}
```

或者使用一个变量来承载其他值：

```rust
#[derive(Debug)]
enum Direction {
  East,
  West,
  North,
  South,
}

fn main() {
  let dire = Direction::South;
  match dire {
    Direction::East => println!("East"),
    other => println!("other direction: {:?}", other),
  };
}
```

### `if let` 匹配

> **当你只要匹配一个条件，且忽略其他条件时就用 `if let` ，否则都用 `match`。**

```rust
fn main() {
  if let Some(3) = v {
    println!("three");
  }
}
```

### `matches!`宏

`Rust` 标准库中提供了一个非常实用的宏：`matches!`，它可以将一个表达式跟模式进行匹配，然后返回匹配的结果 `true` or `false`。

```rust
enum MyEnum {
  Foo,
  Bar,
}

fn main() {
  let v = vec![MyEnum::Foo, MyEnum::Bar, MyEnum::Foo];

  let foo = 'f';
  assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));

  let bar = Some(4);
  assert!(matches!(bar, Some(x) if x > 2));
}
```

### 变量遮蔽

`match` 和 `if let`中的变量会遮蔽前面定义的变量，如：

```rust
fn main() {
  let age = Some(30);
  println!("在匹配前，age是{:?}", age);
  if let Some(age) = age {
    println!("匹配出来的age是{}", age);
  }

  println!("在匹配后，age是{:?}", age);
}
```

输出如下：

```
在匹配前，age是Some(30)
匹配出来的age是30
在匹配后，age是Some(30)
```

## 解构Option

`Option` 枚举用来解决 `Rust` 中变量是否有值的问题，其定义如下：

```rust
fn main() {
  enum Option<T> {
    Some(T),
    None,
  }
}
```

> **一个变量要么有值：Some(T), 要么为空：None**

### 匹配`Option<T>`

使用 `Option<T>`，是为了从 `Some` 中取出其内部的 `T` 值以及处理没有值的情况：

```rust
fn main() {
  fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
      None => None,
      Some(i) => Some(i + 1),
    }
  }

  let five = Some(5);
  let six = plus_one(five);
  let none = plus_one(None);
}
```

## 模式适用场景

模式是 `Rust` 中的特殊语法，它用来匹配类型中的结构和数据，它往往和 `match` 表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：

- 字面值
- 解构的数组、枚举、结构体或者元组
- 变量
- 通配符
- 占位符

### `match` 分支

```rust
fn main() {
  match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
  }
}
```

`match` 的每个分支就是一个模式，因为 `match` 匹配是穷尽式的，因此我们往往需要一个特殊的模式 `_`，来匹配剩余的所有情况：

```rust
fn main() {
  match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    _ => EXPRESSION,
  }
}
```

### `if let` 分支

`if let` 往往用于匹配一个模式，而忽略剩下的所有模式的场景：

```rust
fn main() {
  if let PATTERN = SOME_VALUE {}
}
```

### `while let` 条件循环

`while let` 条件循环类似`if let` ，它允许只要模式匹配就一直进行 `while` 循环：

```rust
fn main() {
  // 创建一个动态数组
  let mut stack = Vec::from([1, 2, 3]);
  // 当数组中弹出元素为空终止
  while let Some(top) = stack.pop() {
    println!("{}", top);
  }
}
```

### `for` 循环

```rust
fn main() {
  let v = vec!['a', 'b', 'c'];

  for (index, value) in v.iter().enumerate() {
    println!("{} is at index {}", value, index);
  }
}
```

这里使用 `enumerate` 方法产生一个迭代器，该迭代器每次迭代会返回一个 (索引，值) 形式的元组，然后用 (`index`,`value`) 来匹配。

### `let` 语句

```rust
fn main() {
  let x = 5;
}
```

`x` 也是一种模式绑定，代表**将匹配的值绑定到变量 `x` 上**。因此，**在 `Rust` 中,变量名也是一种模式**，只不过它比较朴素很不起眼罢了。

### 函数参数

函数参数也是模式：

```rust
fn main() {
  // x是匹配模式
  fn foo(x: i32) {
    // 代码
  }
}

fn print_coordinates(&(x, y): &(i32, i32)) {
  println!("Current location: ({}, {})", x, y);
}

fn main() {
  // &(3, 5) 会匹配模式 &(x, y)，因此 x 得到了 3，y 得到了 5
  let point = (3, 5);
  print_coordinates(&point);
}
```

### `let` 和 `if let`

`let` , `for`和`match `都必须要求完全覆盖匹配，才能通过编译( **不可驳模式匹配** )。
`if let` 允许匹配一种模式，而忽略其余的模式( **可驳模式匹配** )

## 全模式列表

本届内容是将模式语法都罗列出来

### 匹配字面值

如果希望代码获得特定的具体值，那么这种语法很有用：

```rust
fn main() {
  let x = 1;

  match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
  }
}
```

### 匹配命名变量

```rust
fn main() {
  let x = Some(5);
  let y = 10;
  match x {
    Some(50) => println!("50"),
    // 变量覆盖，引入新变量y，匹配任何Some的值
    Some(y) => println!("{}", y),
    _ => println!("default")
  }
}
```

### 单分支模式

在 `match` 表达式中，可以使用 `|` 语法匹配多个模式，它代表**或**的意思：

```rust
fn main() {
  let x = 1;

  match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
  }
}
```

### 通过序列 `..=` 匹配值的范围

序列语法语法不仅可以用于循环中，还能用于匹配模式。
`..=` 语法允许你匹配一个闭区间序列内的值。在如下代码中，当模式匹配任何在此序列内的值时，该分支会执行：

```rust
fn main() {
  let x = 5;

  match x {
    // 匹配1-5（包含5）
    1..=5 => println!("one through five"),
    // 匹配其他情况
    _ => println!("something else"),
  }
}
```

### 解构并分解值

#### 解构结构体

```rust
struct Point {
  x: i32,
  y: i32,
}

fn main() {
  let p = Point { x: 0, y: 7 };

  // 模式中的变量名不必与结构体中的字段名一致，如果变量名和结构体字段名一直，则可以省略
  let Point { x: a, y } = p;
  assert_eq!(0, a);
  assert_eq!(7, b);
}
```

也可以使用字面值作为结构体模式的一部分进行解构，而不是为所有的字段创建变量。这允许我们测试一些字段为特定值的同时创建其他字段的变量：

```rust
struct Point {
  x: i32,
  y: i32,
}

fn main() {
  let p = Point { x: 0, y: 20 };
  match p {
    // 匹配y为0的情况
    Point { x, y: 0 } => println!("{}", x),
    // 匹配x为0的情况
    Point { x: 0, y } => println!("{}", y),
    // 匹配x、y都不为0的情况
    Point { x, y } => println!("{},{}", x, y)
  }
}
```

#### 解构枚举

```rust
enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(i32, i32, i32),
}

fn main() {
  let msg = Message::ChangeColor(0, 160, 255);

  match msg {
    // 匹配Message::Quit字面量
    Message::Quit => {
      println!("The Quit variant has no data to destructure.")
    }
    Message::Move { x, y } => {
      println!(
        "Move in the x direction {} and in the y direction {}",
        x,
        y
      );
    }
    Message::Write(text) => println!("Text message: {}", text),
    Message::ChangeColor(r, g, b) => {
      println!(
        "Change the color to red {}, green {}, and blue {}",
        r,
        g,
        b
      )
    }
  }
}
```

#### 解构嵌套的结构体和枚举

```rust
enum Color {
  Rgb(i32, i32, i32),
  Hex(String),
}

enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(Color),
}

fn main() {
  let msg = Message::ChangeColor(Color::Rgb(255, 255, 255));

  match msg {
    // 匹配Message::ChangeColor里的Color::Rgb
    Message::ChangeColor(Color::Rgb(r, g, b)) => {
      println!(
        "Change the color to red {}, green {}, and blue {}",
        r,
        g,
        b
      )
    }
    // 匹配Message::ChangeColor里的Color::Hex
    Message::ChangeColor(Color::Hex(color)) => {
      println!(
        "Change the color is {}", color)
    }
    _ => {}
  }
}
```

#### 解构结构体和元组

我们甚至可以用复杂的方式来混合、匹配和嵌套解构模式。

```rust
struct Point {
  x: i32,
  y: i32,
}

fn main() {
  let ((r), Point { x }) = ((255, 255, 255), Point { x: 32, y: 20 });
  println!("rgb({},{},{})", r, g, b);
  println!("x:{},y:{}", x, y);
}
```

#### 解构数组
定长数组
```rust
fn main() {
  let arr: [u8; 4] = [1, 2, 3, 4];
  // 使用..忽略后面未解构的元素
  let [x, y, ..] = arr;
  println!("{},{}", x, y);
}
```
不定长数组：
```rust
fn main() {
  let arr: &[u8] = &[1, 2, 3, 4, 5];
  if let [x, ..] = arr {
    println!("{}", x);
  }
  if let &[.., y] = arr {
    println!("{}", y);
  }
  let arr: &[u8] = &[];
  println!("{}",matches!(arr,[..]));
  println!("{}",matches!(arr,[x,..]));
}
```
### 忽略模式中的值