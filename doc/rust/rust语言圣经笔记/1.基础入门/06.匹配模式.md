# 模式匹配

## `match`和`if let`

### `match`匹配

Rust中的`match`和其他语言中的`switch`相似，如：

```rust
enum Direction {
  East,
  West,
  North,
  South,
}

fn main() {
  let dire = Direction::South;
  // match 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同
  match dire {
    Direction::East => println!("East"),
    // X | Y，类似逻辑运算符 或，代表该分支可以匹配 X 也可以匹配 Y，只要满足一个即可
    Direction::North | Direction::South => {
      println!("South or North");
    }
    // match 的匹配必须要穷举出所有可能，因此这里用 _ 来代表未列出的所有可能性
    _ => println!("West"),
  };
}
```

`match`的通用形势如下：

```
fn main() {
  match target {
    模式1 => 表达式1,
    模式2 => {
        语句1;
        语句2;
        表达式2
    },
    _ => 表达式3
  }
}
```
#### 使用`match`表达式赋值
`match`本身也是个表达式，可用于赋值：

```rust
enum IpAddr {
  Ipv4,
  Ipv6,
}

fn main() {
  let ip1 = IpAddr::Ipv6;
  let ip_str = match ip1 {
    IpAddr::Ipv4 => "127.0.0.1",
    _ => "::1",
  };

  println!("{}", ip_str);
}
```
#### 模式绑定
模式匹配有个重要的功能就是从模式中取值，如：
```rust
enum Action {
  Say(String),
  MoveTo(i32, i32),
  ChangeColor(u8, u8, u8),
}

fn main() {
  let actions = [
    Action::Say("hello".to_string()),
    Action::MoveTo(20, 30),
    Action::ChangeColor(255, 255, 255),
  ];
  for action in actions {
    match action {
      Action::Say(s) => { println!("{}", s); }
      Action::MoveTo(x, y) => { println!("move to ({},{})", x, y); }
      Action::ChangeColor(r, g, b) => { println!("color is rgb({},{},{})", r, g, b); }
    }
  }
}
```
#### 穷尽匹配
`match`的匹配必须穷尽所有情况，如：

```rust
enum Direction {
  East,
  West,
  North,
  South,
}

fn main() {
  let dire = Direction::South;
  match dire {
    Direction::East => println!("East"),
    Direction::North | Direction::South => {
      println!("South or North");
    }
  };
}
```
将会报错如下信息：
```
error[E0004]: non-exhaustive patterns: `West` not covered // 非穷尽匹配，`West` 没有被覆盖
  --> src/main.rs:10:11
   |
1  | / enum Direction {
2  | |     East,
3  | |     West,
   | |     ---- not covered
4  | |     North,
5  | |     South,
6  | | }
   | |_- `Direction` defined here
...
10 |       match dire {
   |             ^^^^ pattern `West` not covered // 模式 `West` 没有被覆盖
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Direction`
```
#### `_` 通配符
`match`匹配中可通过`_`通配符匹配所有没有列出的项：
```rust

#![allow(unused)]

fn main() {
  let some_u8_value = 0u8;
  match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
  }
}
```
或者使用一个变量来承载其他值：
```rust
#[derive(Debug)]
enum Direction {
  East,
  West,
  North,
  South,
}

fn main() {
  let dire = Direction::South;
  match dire {
    Direction::East => println!("East"),
    other => println!("other direction: {:?}", other),
  };
}
```
### `if let` 匹配
> **当你只要匹配一个条件，且忽略其他条件时就用 `if let` ，否则都用 `match`。**
```rust
fn main() {
  if let Some(3) = v {
    println!("three");
  }
}
```
### `matches!`宏
`Rust` 标准库中提供了一个非常实用的宏：`matches!`，它可以将一个表达式跟模式进行匹配，然后返回匹配的结果 `true` or `false`。

```rust
enum MyEnum {
  Foo,
  Bar,
}

fn main() {
  let v = vec![MyEnum::Foo, MyEnum::Bar, MyEnum::Foo];
  
  let foo = 'f';
  assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));

  let bar = Some(4);
  assert!(matches!(bar, Some(x) if x > 2));
}
```