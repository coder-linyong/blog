# 基本类型

Rust每个值都有确切的类型，可分为两种：基本数据类型和复合类型。

基本数据类型最小原子类型，无法结构成其他类型：

- 数值类型: 有符号整数 (`i8`,` i16`, `i32`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`,` u32`, `u64`, `usize`)
  、浮点数 (`f32`, `f64`)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 `&str`
- 布尔类型： `true`和`false`
- 字符类型: 表示单个 `Unicode` 字符，存储为 4 个字节
- 单元类型: 即 () ，其唯一的值也是 ()

## 类型推导与标注

与 Python、JavaScript 等动态语言不同，Rust 是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为
**Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型**
，同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注。

## 数值类型

### 整数类型

**整数**是没有小数部分的数字。`i`是英文单词integer的首字母，与之相反的是`u`，代表无符号unsigned类型。

| 长度    | 有符号类型 | 无符号类型 |
|-------|-------|-------|
| 8位    | i8    | u8    |
| 16位   | i16   | u16   |
| 32位   | i32   | u32   |
| 64位   | i64   | u64   |
| 128位  | i128  | u128  |
| 视框架而定 | isize | usize |

- 有符号类型规定数字是-(2n-1) ~ 2n-1 - 1，其中n是该定义形式的位长度，如：`i8`可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~127。
- 有符号类型可存储数字范围是0 ~ 2n - 1，所以 `u8` 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。
- `isize`和`usize`取决于计算机CPU类型：CPU是32位的，则是32位的；CPU是64位的，则是64位的

整形字面量可以使用下面形式书写：

| 数字字面量       | 示例          |
|-------------|-------------|
| 十进制         | 98_222      |
| 十六进制        | 0xff        |
| 八进制         | 0o77        |
| 二进制         | 0b1111_0000 |
| 字节 (仅限于 u8) | b'A'        |

**Rust整形默认使用i32类型，建议首选，因为这个类型往往是性能最好的类型；**`**isize**`**和**`**usize**`**的场景主要用作集合的索引
**

**整形溢出**
当一个值修改到其范围之外的值时，会发生**整形溢出**，Rust对于**整形溢出**有些有趣的规则：

- 使用debug模式编译时，Rust会检查**整形溢出**，如果存在则会在编译时崩溃（panic，Rust使用这个术语表达程序因错误而退出）
- 使用`--release`参数进行release模式构建时，Rust不检测溢出。Rust会按照补码循环溢出（two’s complement
  wrapping）的规则处理；如在`U8`的情况下，265变成0,257变成1，以此类推。程序不会崩溃，但这种行为是一种Bug，处理这些行为的方法如下
    - 使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
    - 如果使用 checked_* 方法时发生溢出，则返回 None 值
    - 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
    - 使用 saturating_* 方法使值达到最小值或最大值

```rust
fn main() {
  let mut num: u8 = 255;
  num = num.wrapping_add(10);
  println!("{}", num);//9
}
```

### 浮点类型

**浮点类型数字**是带有小数的数字，在Rust中浮点类型数字有两种基本类型：

- f32（单精度浮点型）
- f64（双精度浮点型，默认浮点类型，与f32速度几乎相同，但精度更高）

**浮点数陷阱**
浮点数由于底层特殊性，导致如果在使用浮点数时不够谨慎，可能会造成危险，原因如下：

- **浮点数往往是某个数字的近似表达**：浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1
  在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行
- **浮点数在某些特性上是反直觉的**：如f32 ， f64 上的比较运算实现的是 std::cmp::PartialEq 特征(类似其他语言的接口)，但是并没有实现
  std::cmp::Eq 特征，但是后者在其它数值类型上都有定义

为了避免上面说的两个陷阱，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

### NaN

数学中未定义的结果，如对负数取平方根（`-42.1.sqrt()`），会产生一个特殊的结果：Rust的浮点数类型使用NaN（not a number）来处理这些情况。

**所有跟NaN交互的操作，都会返回NaN，而且NaN不能用来比较**，下面的代码将会崩溃：

```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```

可使用`is_nan`等方法判断是否是`NaN`：

```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  if x.is_nan() {
    println!("未定义的数学行为")
  }
}
```

### 数字运算

Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。

```rust
fn main() {
  // 加法
  let sum = 5 + 10;

  // 减法
  let difference = 95.5 - 4.3;

  // 乘法
  let product = 4 * 30;

  // 除法
  let quotient = 56.7 / 32.2;

  // 求余
  let remainder = 43 % 5;
}
```

```rust
fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;

  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];

  // 打印数组中第一个值，并控制小数位为2位
  println!("{:.2}", forty_twos[0]);
}
```

### 位运算

Rust的运算基本上和其他语言一样

| 运算符       | 说明                           |
|-----------|------------------------------|
| & 位与      | 相同位置均为1时则为1，否则为0             |
| &#124; 位或 | 相同位置只要有1时则为1，否则为0            |
| ^ 异或      | 相同位置不相同则为1，相同则为0             |
| ! 位非      | 把位中的0和1相互取反，即0置为1，1置为0       |
| << 左移     | 所有位向左移动指定位数，右位补0             |
| >> 右移     | 所有位向右移动指定位数，带符号移动（正数补0，负数补1） |

```rust
fn main() {
  // 二进制为00000010
  let a: i32 = 2;
  // 二进制为00000011
  let b: i32 = 3;

  println!("(a & b) value is {}", a & b);

  println!("(a | b) value is {}", a | b);

  println!("(a ^ b) value is {}", a ^ b);

  println!("(!b) value is {} ", !b);

  println!("(a << b) value is {}", a << b);

  println!("(a >> b) value is {}", a >> b);

  let mut a = a;
  // 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)
  a <<= b;
  println!("(a << b) value is {}", a);
}
```

### 序列

Rust提供一个非常简洁的方式生成连续的数值，如：1..5表示生成1到4的连续数字，不包含5；1..=5表示从1到5连续的数字，包含5：

```rust
fn main() {
  for i in 1..=5 {
    println!("{}", i);
  }
}
```

同事，能够用于字符类型（字符可以连续，a-z），同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型：

```rust
fn main() {
  for i in 'a'..='z' {
    println!("{}", i)
  }
  for i in 'A'..='Z' {
    println!("{}", i)
  }
}
```

### 有理数和复数

Rust中有理数和复数并未包含在标准库中：

- 有理数和复数
- 任意大小的整数和任意精度的浮点数
- 固定精度的十进制小数，常用于货币相关的场景

社区中高质量Rust数值库[num](https://crates.io/crates/num)可解决这种问题

```rust
use num::complex::Complex;

fn main() {
  let a = Complex { re: 2.1, im: -1.2 };
  let b = Complex::new(11.1, 22.2);
  let result = a + b;

  println!("{} + {}i", result.re, result.im)
}
```

## 字符、布尔、单元类型

### 字符类型（char)

Rust中，所有的`Unicode`（U+0000 ~ U+D7FF）值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。

由于 Unicode 都是 4 个字节编码，因此字符类型也是占用 4 个字节：

```rust
fn main() {
  let x = 'a';
  println!("{}", std::mem::size_of_val(&x));//4
}
```

### 布尔（bool）

布尔类型只有两个值`true`和`false`，占用内存大小为1字节。

```rust
fn main() {
  let t = true;

  let f: bool = false; // 使用类型标注,显式指定f的类型

  if f {
    println!("这是段毫无意义的代码");
  }
}
```

### 单元类型

单元类型是`()`，同时`()`也是单元类型唯一的值。如：`main`函数和`println!()`函数返回的都是单元类型。

**单元类型可以作为一个值用来占位，但完全不占用任何内存**

## 语句和表达式

- 语句：以`;`结尾，执行操作但不返回任何值
- 表达式：不以`;`结尾，执行操作并返回值，**只要能够返回值的都是表达式**;表达式如果不返回任何职，则会默认返回`()`

> 对于 Rust 语言而言，**这种基于语句（statement）和表达式（expression）的方式是非常重要的，你需要能明确的区分这两个概念**,
> 但是对于很多其它语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征，**表达式总要返回值**。

```rust
fn main() {
  fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
  }
}
```

## 函数

一个函数如下结构：

```rust
fn main() {
  fn add(i: i32, j: i32) -> i32 {
    i + j
  }
}
```

结构说明：

- 声明函数的关键字`fn`
- 函数名`add()`
- 参数`i`和`j`
- 参数类型和返回值类型都是`i32`

### 函数要点

- 函数名和变量名使用[蛇形命名法(snake case)](https://course.rs/practice/naming.html)，例如 fn add_two() -> {}
- 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
- 每个函数参数都需要标注类型

### 函数参数

Rust是强类型语言，因此需要为每个函数参数都标识出具体类型，如：

```rust
fn main() {
  another_function(5, 6.1);
}

fn another_function(x: i32, y: f32) {
  println!("The value of x is: {}", x);
  println!("The value of y is: {}", y);
}
```

### 函数返回

Rust中函数是表达式，函数返回值可以直接赋值给调用者，在函数中可通过return提前返回值，或者通过最后一行的表达式返回值：

```rust
fn main() {
  println!("{}", fun(120))
}

fn fun(n: i32) -> i32 {
  // 大于100，提前返回
  if n > 100 {
    return n - 10;
  }
  n + 10
}
```

#### 特殊返回类型

##### 无返回值()

单元类型`()`可以用来表达一个函数没有返回值

- 函数没有返回值，那么返回一个`()`
- 通过`;`结尾的表达式返回一个`()`

```rust
// 隐式返回()
fn report<T: Debug>(item: T) {
  println!("{:?}", item);
}

// 显式返回()
fn clear(text: &mut String) -> () {
  *text = String::from("");
}
```

##### 永不返回的发散函数 !

当用`!`作函数返回类型的时候，表示该函数永不返回（diverge function），特别的，这种语法往往用做会导致程序崩溃的函数：

```rust
// 程序崩溃时
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}

// 无限循环时
fn forever() -> ! {
  loop {
    //...
  };
}
```