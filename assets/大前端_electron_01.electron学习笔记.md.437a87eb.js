import{_ as i,o as l,c as e,M as o}from"./chunks/framework.df29e205.js";const a="/blog/assets/img1.8c2e62b3.png",r="/blog/assets/img2.7ba06b23.png",t="/blog/assets/img.34c566c7.png",c="/blog/assets/img_1.85f9087f.png",P=JSON.parse('{"title":"学习笔记","description":"","frontmatter":{},"headers":[],"relativePath":"大前端/electron/01.electron学习笔记.md","lastUpdated":1700900293000}'),s={name:"大前端/electron/01.electron学习笔记.md"},n=o('<h1 id="学习笔记" tabindex="-1">学习笔记 <a class="header-anchor" href="#学习笔记" aria-label="Permalink to &quot;学习笔记&quot;">​</a></h1><h2 id="架构原理" tabindex="-1">架构原理 <a class="header-anchor" href="#架构原理" aria-label="Permalink to &quot;架构原理&quot;">​</a></h2><h3 id="chromium架构" tabindex="-1">chromium架构 <a class="header-anchor" href="#chromium架构" aria-label="Permalink to &quot;chromium架构&quot;">​</a></h3><p><img src="'+a+'" alt="chromium架构图"> 一个浏览器中会有如下进程：</p><ul><li>一个browser进程（主进程）</li><li>多个render进程（渲染进程）</li></ul><p><strong>通信</strong>：进程间通过IPC通信进行通信，<code>RenderProcessHost</code>和<code>RenderProcess</code>专门用于处理IPC事件</p><p><strong>ResourceDispatcher</strong>：对资源请求进行处理</p><h3 id="electron架构" tabindex="-1">electron架构 <a class="header-anchor" href="#electron架构" aria-label="Permalink to &quot;electron架构&quot;">​</a></h3><p><img src="'+r+'" alt="electron架构图"></p><h4 id="主进程" tabindex="-1">主进程 <a class="header-anchor" href="#主进程" aria-label="Permalink to &quot;主进程&quot;">​</a></h4><ul><li>Electron运行<code>package.json</code>的main脚本的进程被称为主进程</li><li>每个应用只有一个主进程</li><li>管理原生 GUI，典型的窗口 (BrowserWindow、Tray、Dock、Menu)</li><li>创建渲染进程</li><li>控制应用生命周期 (app)</li></ul><h3 id="node-js与chromiums事件融合" tabindex="-1">Node.js与Chromiums事件融合 <a class="header-anchor" href="#node-js与chromiums事件融合" aria-label="Permalink to &quot;Node.js与Chromiums事件融合&quot;">​</a></h3><p>Node.js事件循环基于<code>libuv</code>，<code>libuv</code>引入了<code>backend_fd</code>概念——<code>libuv</code>轮询事件的文件描述符；通过轮询<code>backend_fd</code>可以知道libuv`的新事件。</p><p>Electron创建一个新的安全线程轮询<code>backend_fd</code>，Node.js有新事件之后通过<code>PostTask</code>转发到chromium的事件循环中：</p><p><img src="'+t+'" alt="事件融合"></p><h2 id="桌面端技术对比" tabindex="-1">桌面端技术对比 <a class="header-anchor" href="#桌面端技术对比" aria-label="Permalink to &quot;桌面端技术对比&quot;">​</a></h2><ul><li>Native(C++/C#/0bjective-C) <ul><li>高性能</li><li>原生体验</li><li>包体积小</li><li>门槛高</li><li>迭代速度慢</li></ul></li><li>QT <ul><li>基于C++</li><li>跨平台(Mac、Windows、ios、Android、Linux、嵌入式)</li><li>高性能</li><li>媲美原生的体验</li><li>门槛高</li><li>迭代速度一般</li></ul></li><li>Fluter <ul><li>跨端(ios、Android、Mac、Windows、Linux、Web)</li><li>PC 端在发展中 (Mac &gt; Linux、Windows)</li><li>基建少</li></ul></li><li>NW.js <ul><li>跨平台 (Mac、Windows、Linux)，v0.14.7支持XP(XP 市场份额约为15%)</li><li>迭代快，Web 技术构建</li><li>源码加密、支持 Chrome 扩展</li><li>不错的社区</li><li>包体积大</li><li>性能一般</li></ul></li><li>Electron <ul><li>跨平台 (Mac、Windows、Linux、不支持 XP)</li><li>Web 技术构建</li><li>活跃的社区</li><li>大型应用案例</li><li>包体积大</li><li>性能一般 <img src="'+c+'" alt="对比图"></li></ul></li></ul>',17),d=[n];function u(h,m,_,p,b,g){return l(),e("div",null,d)}const k=i(s,[["render",u]]);export{P as __pageData,k as default};
